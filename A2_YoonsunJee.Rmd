---
title: "Assignment 2"
output:
  html_document:
    df_print: paged
author: "Joelle Jee"
---
## Recap of Assignment 1
Publication Title: Disruption of the MBD2-NuRD complex but not MBD3-NuRD induces high level HbF expression in human adult erythroid cells\
Publication Date: 2019 Dec\
Publication Journal: Haematologica\
GEOID: GSE121992\
\
This study was able to prove that the Nucleosome Remodeling and Deacetylase complex member MBD2 knock-out in primary human erythroid cells were able to significantly elevate the gamma/gamma+beta mRNA expresssion of HbF, which is known in the literature to benefit sickle cell anemia patients.\
They performed RNA-sequencing of the MBD2KO and the control (sgCSR) cells before and after differentiation to measure the effect of deficiency of MBD in erythroid differentiation.\
They found that MBD2KO in primary human erythroid cells significantly elevate the gamma/gamma+beta mRNA expresssion of HbF without changing the morphological appearance after differentiation compared to controls. From this finding, the authors proposed that therapies targeting MBD2 can ameliorate the underlying pathophysiological defects in sickle cell anemia and beta (beta)-thalassemia.\
\
In assignment 1, the dataset was cleaned by removing outliers, and non-informative datapoints, and mapped to HUGO gene symbols, and normalized using Timmed Mean of M-Values. In this assignment, the genes will be ranked according to differential expression and I will perform enrichment analysis to see the dominant themes in the top hits.

## Load required packages

We will first load the required packages to clean, normalize and interpret the data.

```{r setup, message = FALSE, results = "hide"}
knitr::opts_chunk$set(warning = FALSE)

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!requireNamespace("GEOquery", quietly = TRUE)) {
  BiocManager::install("GEOquery")
}

if (!requireNamespace("biomaRt", quietly = TRUE)) {
  BiocManager::install("biomaRt")
}

if (!requireNamespace("edgeR", quietly = TRUE)) {
  BiocManager::install("edgeR")
}

if (!requireNamespace("ComplexHeatmap")) {
  BiocManager::install("ComplexHeatmap")
}

if (!requireNamespace("circlize")) {
  BiocManager::install("circlize")
}

if (!requireNamespace("limma")) {
  BiocManager::install("limma")
}

if (!requireNamespace("enrichR")){
  devtools::install_github("wjawaid/enrichR")
}

if (!requireNamespace("kableExtra")){
  install.packages("kableExtra")
}
```
## Data Overview

Download the dataset (GEO accession: GSE121992) using package GEOquery.

```{r, message = FALSE, results = "hide"}
HbF_gse <- GEOquery::getGEO("GSE121992", GSEMatrix = FALSE)
HbF_gpl <- names(GEOquery::GPLList(HbF_gse))[1]
HbF_gpl_info <- GEOquery::Meta(GEOquery::getGEO(HbF_gpl))
```

### Platform Information
**Title of Platform:** `r HbF_gpl_info$title`\
**Submission Date:** `r HbF_gpl_info$submission_date`\
**Last Update Date:** `r HbF_gpl_info$last_update_date`\
**Organism:** `r HbF_gpl_info$organism`\
**Number of GEO datasets using this study:** `r length(HbF_gpl_info$series_id)`\
**NUmber of GEO samples using this study:** `r length(HbF_gpl_info$sample_id)`

## Load and visualize the cleaned, normalized data
Load the cleaned data saved in the data folder from Assignment 1.
```{r}
normalized_count_data <- read.table(file = file.path("data", "GSE121992_finalized_normalized_counts.txt"),
                                    header = TRUE, sep = "\t",
                                    stringsAsFactors = FALSE,
                                    check.names = FALSE)

normalized_count_data[1:5, 1:5]
```

A heatmap is a data graph that maps the measurements of many samples to a colour scale to allow better visualization of the overall tred of the data. With a heatmap, we can manipulate the format to highlight the themes in the data.\

We will first visualize the above data using a heatmap.\

To do so, first create a numerical matrix of the data.
```{r}
heatmap_matrix <- normalized_count_data
rownames(heatmap_matrix) <- rownames(normalized_count_data)
colnames(heatmap_matrix) <- colnames(normalized_count_data)
```

Now we can create a heatmap.
```{r}
# set color scale according to value
if(min(heatmap_matrix) == 0) {
  heatmap_col = circlize::colorRamp2(c(0, max(heatmap_matrix)), c("white", "red"))
} else {
  heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix), 0, max(heatmap_matrix)), c("blue", "white", "red"))
}
# draw the heatmap
current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix),
                                           show_row_dend = TRUE,
                                           show_column_dend = TRUE,
                                           col = heatmap_col,
                                           show_column_names = TRUE,
                                           show_row_names = FALSE,
                                           show_heatmap_legend = TRUE)


current_heatmap
```

As you can see, the above graph does not tell us any information. This is because the data is yet to be row-normalized, which is a method of scaling each row and centering them around the mean. The R function scale() takes each value and subtract the mean and divide by the standard deviaiton of the row to row normalize it. Let's row-normalize the data and compare the heatmap drawn from it to the above heatmap.

```{r}
# row normalize
heatmap_matrix <- t(scale(t(heatmap_matrix)))

# set color scale according to value
if (min(heatmap_matrix) == 0) {
  heatmap_col = circlize::colorRamp2(c(0, max(heatmap_matrix)), c("white", "red"))
} else {
  heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix), 0, max(heatmap_matrix)), c("blue", "white", "red"))
}

# draw the heatmap
current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix),
                                           show_row_dend = TRUE,
                                           show_column_dend = TRUE,
                                           col = heatmap_col,
                                           show_column_names = TRUE,
                                           show_row_names = FALSE,
                                           show_heatmap_legend = TRUE)

current_heatmap
```

## Defining differential expression with Limma

### Group and Cluster
We will be using linear models of microarray (Limma), which uses linear models to define differential expression.\
Using the limma package, let's see how our samples are clustering with MDSPlot.
```{r}
# set color scale
sample_col <- rainbow(4)
sample_col <- unlist(lapply(sample_col, 
                            FUN = function(x){rep(x, 3)}))
# draw the MDSPlot to see the clustering by sample
limma::plotMDS(heatmap_matrix, 
               col = sample_col)
```

Now we will define the groups and store it in variable samples.
```{r}
# parse the column names to replication number rep
# and cell type (e.g. sgSCR_pre_r1 to sgSCR_pre and r1)
samples <- data.frame(
  lapply(colnames(normalized_count_data), 
         FUN=function(x){
           x_split <- unlist(strsplit(x, split = "_"))
           rep <- x_split[3]
           cell_type <- paste(x_split[c(1, 2)], collapse = "_")
           return (c(rep, cell_type))}))

# set column and row names
colnames(samples) <- colnames(normalized_count_data)
rownames(samples) <- c("replication","cell_type")

# Group and view samples
samples <- data.frame(t(samples))
samples[1:5,]
```

### Create ExpressionSet

Let's use an R function, model.matrix, to create a design matrix.
```{r}
# create a design matrix for our dataset
model_design <- model.matrix(~ samples$cell_type)
model_design
```

Now create our data matrix usign ExpressionSet
```{r}
expressionMatrix <- as.matrix(normalized_count_data)
rownames(expressionMatrix) <- rownames(normalized_count_data)
colnames(expressionMatrix) <- colnames(normalized_count_data)

# create an ExpressionSet object of our dataset
minimalSet <- Biobase::ExpressionSet(assayData=expressionMatrix)

```

Fit our data to the above model
```{r}
fit <- limma::lmFit(minimalSet, model_design)
```

Apply empirical Bayes (function eBayes from package limma) and compute the differential expression for the above model. This essentially computes the probability of any gene being differentially expressed given its constrasts. 
```{r}
fit2 <- limma::eBayes(fit,trend=TRUE)
# extract the top-ranked genes from the linear model fit (fit2)
output_hits <- limma::topTable(fit2,
                               coef=c(2:ncol(model_design)),
                               adjust.method = "BH",
                               number = nrow(expressionMatrix))

#sort by pvalue
output_hits <- output_hits[order(output_hits$P.Value),]

output_hits[1:10,]
```

### Genes that pass the threshold
Let's see how many genes pass the threshold p-values of 0.05. The threshold of 0.05 is chosen as it is the most widely accept p-value as it means that there are less than 5% chance of a positive result from mere chance. I will be using this threshold throughout this assignment.

```{r}
length(which(output_hits$P.Value < 0.05))

```

... and genes that pass correction.
```{r}
length(which(output_hits$adj.P.Val < 0.05))

```

## Multiple Hypothesis Correction
We need to correct the p-values using a multiple hypothesis correction method because we need to account for the fact the likelihood of positive result is enhanced by number or replications of each sample. For example, since we have 3 replications of each cell type, the likelihood of positive outcome in at least of the replications is increased by 3.\  
To control for family-wise error rate or for false discovery rate, we will use the BH (Benjamini-Hochberg) method. Also we will account for replication variability.
```{r}
model_design_pat <- model.matrix( ~ samples$replication + samples$cell_type)
model_design_pat
```

Now fit our data to the above model
```{r}
fit_pat <- limma::lmFit(minimalSet, model_design_pat)
```

... and apply empirical Bayes to compute differential expression for the above described model, except now with the adjust.method = "BH".
```{r}
fit2_pat <- limma::eBayes(fit_pat,trend=TRUE)
output_hits_pat <- limma::topTable(fit2_pat, 
                                   coef=c(2:ncol(model_design_pat)),
                                   adjust.method = "BH",
                                   number = nrow(expressionMatrix))

#sort by pvalue
output_hits_pat <- output_hits_pat[order(output_hits_pat$P.Value),]

output_hits_pat[1:10,]
```

Let's now see if the number of genes that pass the threshold p-value has changed.
```{r}
length(which(output_hits_pat$P.Value < 0.05))
```

... and geens that pass correction
```{r}
length(which(output_hits_pat$adj.P.Val < 0.05))
```

Just by looking at the numbers, we can see that Multiple Hypothesis Correction decreased the number of genes that passed the threholds.\

### Comparing the results from two different models

Let's now compare the results from the two different models.
```{r}
simple_model_pvalues <- data.frame(hgnc = rownames(output_hits),
                                   simple_pvalue=output_hits$P.Value)
pat_model_pvalues <-  data.frame(hgnc = rownames(output_hits_pat),
                                 patient_pvalue = output_hits_pat$P.Value)
two_models_pvalues <- merge(simple_model_pvalues,
                            pat_model_pvalues,by.x=1,by.y=1)
two_models_pvalues$colour <- "black"
two_models_pvalues$colour[two_models_pvalues$simple_pvalue<0.05] <- "orange"
two_models_pvalues$colour[two_models_pvalues$patient_pvalue<0.05] <- "blue"
two_models_pvalues$colour[two_models_pvalues$simple_pvalue<0.05 & two_models_pvalues$patient_pvalue<0.05] <- "red"
plot(two_models_pvalues$simple_pvalue,two_models_pvalues$patient_pvalue,
     col = two_models_pvalues$colour,
     xlab = "simple model p-values",
     ylab ="Patient model p-values", 
     main="Simple vs Patient Limma")
```

### Visualization with a heatmap
Coming back to the initial heatmap representation of the data,

```{r}
top_hits <- rownames(output_hits_pat)[output_hits_pat$P.Value<0.05]
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix[
    which(rownames(heatmap_matrix) %in% top_hits),])))
if(min(heatmap_matrix_tophits) == 0){
    heatmap_col = circlize::colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                             c( "white", "red"))
  } else {
    heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix_tophits), 0, max(heatmap_matrix_tophits)), c("blue", "white", "red"))
  }
current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix_tophits),
                                           cluster_rows = TRUE,
                                           cluster_columns = TRUE,
                                           show_row_dend = TRUE,
                                           show_column_dend = TRUE, 
                                           col=heatmap_col,
                                           show_column_names = TRUE, 
                                           show_row_names = FALSE,
                                           show_heatmap_legend = TRUE
)

current_heatmap

```

Let's group the columns by cell type and have argument cluster_columns off, and see the difference. 
```{r}
heatmap_matrix_tophits<- heatmap_matrix_tophits[, 
                                                c(                    
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "sgSCR_pre"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "MBD2KO_pre"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "sgSCR_post"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "MBD2KO_post")
                                                )]
if(min(heatmap_matrix_tophits) == 0){
  heatmap_col = circlize::colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                                     c( "white", "red"))
} else {
  heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix_tophits), 0, max(heatmap_matrix_tophits)), c("blue", "white", "red"))
}
current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix_tophits),
                                           cluster_rows = TRUE,
                                           cluster_columns = FALSE,
                                           show_row_dend = TRUE,
                                           show_column_dend = TRUE, 
                                           col=heatmap_col,
                                           show_column_names = TRUE, 
                                           show_row_names = FALSE,
                                           show_heatmap_legend = TRUE
)

current_heatmap
```

Try for a slightly cleaner picture by rendering just the genes that are in the top hits.

```{r}

top_hits <- rownames(output_hits_pat)[output_hits_pat$P.Value<0.01]
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix[which(rownames(heatmap_matrix) %in% top_hits),]))) 
heatmap_matrix_tophits<- heatmap_matrix_tophits[,
                                                c(                    
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "sgSCR_pre"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "MBD2KO_pre"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "sgSCR_post"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "MBD2KO_post")
                                                )]
if(min(heatmap_matrix_tophits) == 0){
  heatmap_col = circlize::colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                                     c( "white", "red"))
} else {
  heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix_tophits), 0, max(heatmap_matrix_tophits)), c("blue", "white", "red"))
}
current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix_tophits),
                                           cluster_rows = TRUE,  show_row_dend = TRUE,
                                           cluster_columns = FALSE,show_column_dend = FALSE,
                                           col=heatmap_col,show_column_names = TRUE, 
                                           show_row_names = FALSE,show_heatmap_legend = TRUE)

current_heatmap
```

The clustering of the cell types is quite obvious to see. 
## Calculating differential expression with Quali likelihood model
Set up edgeR objects and use the Quali likelihood model to calculate differential expression.
```{r}
# first need to read filtered_data_matrix from Assignment 1
filtered_data_matrix <- read.csv(file = file.path("data", "filtered_data_matrix.csv"),
                                   header = TRUE, sep = ",",
                                   stringsAsFactors = FALSE,
                                   check.names = FALSE,
                                   row.names = 1)
# set up our edgeR objects
d = edgeR::DGEList(counts=filtered_data_matrix, group=samples$cell_type)

# estimate Dispersion - our model design.
d <- edgeR::estimateDisp(d, model_design_pat)

# and fit the model
fit <- edgeR::glmQLFit(d, model_design_pat)

qlf.pos_vs_neg <- edgeR::glmQLFTest(fit, coef=c('samples$cell_typesgSCR_pre',
                                                'samples$cell_typeMBD2KO_pre',
                                                'samples$cell_typesgSCR_post'))

# extract the most differentially expressed genes
edgeR::topTags(qlf.pos_vs_neg)

```

See the results sorted by the p-value.
```{r}
qlf_output_hits <- edgeR::topTags(qlf.pos_vs_neg,sort.by = "PValue",
                           n = nrow(normalized_count_data))

qlf_output_hits[1:10, ]
```

### Genes passing the threshold
How many gene pass the threshold p-value < 0.05?
```{r}
length(which(qlf_output_hits$table$PValue < 0.05))
```

How many genes pass correction?
```{r}
length(which(qlf_output_hits$table$FDR < 0.05))
```

### Compare the results from Limma and Quasi

Limma vs Quasi likelihood results.
```{r}
# Quali likelihood results
qlf_pat_model_pvalues <- data.frame(
          hgnc = rownames(qlf_output_hits$table),
          qlf_patient_pvalue=qlf_output_hits$table$PValue)
# Limma results
limma_pat_model_pvalues <-  data.frame(
          hgnc = rownames(output_hits_pat),
          limma_patient_pvalue = output_hits_pat$P.Value)
# merge the two results
two_models_pvalues <- merge(qlf_pat_model_pvalues,
                            limma_pat_model_pvalues,
                            by.x=1,by.y=1)

# overlap the two results using different colours
two_models_pvalues$colour <- "black"
two_models_pvalues$colour[two_models_pvalues$qlf_patient_pvalue<0.05] <- "orange"
two_models_pvalues$colour[two_models_pvalues$limma_patient_pvalue<0.05] <- "blue"
two_models_pvalues$colour[two_models_pvalues$qlf_patient_pvalue<0.05 & two_models_pvalues$limma_patient_pvalue<0.05] <- "red"
plot(two_models_pvalues$qlf_patient_pvalue,
     two_models_pvalues$limma_patient_pvalue,
     col = two_models_pvalues$colour,
     xlab = "QLF patient model p-values",
     ylab ="Limma Patient model p-values",
     main="QLF vs Limma")
```
### Looking at genes of interest.
We will highlight our genes of interest. I have selected two groups of genes of interest: one for regulation of HbF and the other for differentiation of erythroid cells.
```{r}
HbF_reg <- c("BCL11A", "MYB")
diff_reg <- c("SPI1", "ALAS1", "ALAS2")

two_models_pvalues$colour <- "grey"
# give different colour sfor each genes of interest
two_models_pvalues$colour[two_models_pvalues$hgnc %in% HbF_reg] <- "red"
two_models_pvalues$colour[two_models_pvalues$hgnc %in% diff_reg] <- "blue"

# now plot
plot(two_models_pvalues$qlf_patient_pvalue,
     two_models_pvalues$limma_patient_pvalue,
     col = two_models_pvalues$colour,
     xlab = "QLF patient model p-values",
     ylab ="Limma Patient model p-values",
     main="QLF vs Limma")

# draw the points that correspond to the gene of interest
points(two_models_pvalues[
  two_models_pvalues$hgnc %in% diff_reg,2:3],
       pch=24,  col="blue", cex=1.5)
points(two_models_pvalues[
  two_models_pvalues$hgnc %in% HbF_reg,2:3],
       pch=24,  col="red", cex=1.5)
```

### Visualization with a heatmap
Coming back to the initial heatmap representation of the data
```{r}
# top hits from quasi likelihood results
top_hits <- rownames(qlf_output_hits$table)[output_hits_pat$P.Value<0.05]
# row normalize only the genes in the top hits
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix[which(rownames(heatmap_matrix) %in% top_hits),])))
# set color scale
if(min(heatmap_matrix_tophits) == 0){
  heatmap_col = circlize::colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                                     c( "white", "red"))
  } else {
    heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix_tophits), 0, max(heatmap_matrix_tophits)), c("blue", "white", "red"))
  }

current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix_tophits),
                                           cluster_rows = TRUE,
                                           cluster_columns = TRUE,
                                           show_row_dend = TRUE,
                                           show_column_dend = TRUE, 
                                           col=heatmap_col,
                                           show_column_names = TRUE, 
                                           show_row_names = FALSE,
                                           show_heatmap_legend = TRUE
)
current_heatmap
```

Sort the columns by cell type.
```{r}
# top hits from the quasi likelihood results
top_hits <- rownames(qlf_output_hits$table)[output_hits_pat$P.Value<0.05] 
# row normalize to include just the top hits
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix[which(rownames(heatmap_matrix) %in% top_hits),]))) 
# group by the cell type
heatmap_matrix_tophits<- heatmap_matrix_tophits[, 
                                                c(grep(colnames(heatmap_matrix_tophits),pattern = "sgSCR_pre"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "MBD2KO_pre"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "sgSCR_post"),
                                                  grep(colnames(heatmap_matrix_tophits),pattern = "MBD2KO_post")
                                                )]
# set color scale
if(min(heatmap_matrix_tophits) == 0){
  heatmap_col = circlize::colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                                     c( "white", "red"))
} else {
  heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix_tophits), 0, max(heatmap_matrix_tophits)), c("blue", "white", "red"))
}

current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix_tophits),
                                           cluster_rows = TRUE,
                                           cluster_columns = FALSE,
                                           show_row_dend = TRUE,
                                           show_column_dend = FALSE,
                                           col=heatmap_col,
                                           show_column_names = TRUE, 
                                           show_row_names = FALSE,
                                           show_heatmap_legend = TRUE
)

current_heatmap
```

### Genes that pass the threshold
Let's see how many genes in each cell type (sgSCR_pre, MBD2KO_pre, sgSCR_post) are upregulated compared to cell type MBD2KO_post.
```{r}
# sgSCR_pre
length(which(qlf_output_hits$table$PValue < 0.05 
             & qlf_output_hits$table$logFC.samples.cell_typesgSCR_pre > 0))
# sgSCR_post
length(which(qlf_output_hits$table$PValue < 0.05 
             & qlf_output_hits$table$logFC.samples.cell_typesgSCR_post > 0))
# MBD2KO_pre
length(which(qlf_output_hits$table$PValue < 0.05 
             & qlf_output_hits$table$logFC.samples.cell_typeMBD2KO_pre > 0))
```
... or downregulated
```{r}
# sgSCR_pre
length(which(qlf_output_hits$table$PValue < 0.05 
             & qlf_output_hits$table$logFC.samples.cell_typesgSCR_pre < 0))
# sgSCR_post
length(which(qlf_output_hits$table$PValue < 0.05 
             & qlf_output_hits$table$logFC.samples.cell_typesgSCR_post < 0))
# MBD2KO_pre
length(which(qlf_output_hits$table$PValue < 0.05 
             & qlf_output_hits$table$logFC.samples.cell_typeMBD2KO_pre < 0))
```

## Enrichment Analysis
### Creating thresholded lists of genes
We're going to create thresholded lists of genes.
```{r}
#merge gene names with the top hits
ranked_qlf_output_hits <- qlf_output_hits$table
ranked_qlf_output_hits[,
                       c("sgSCR_pre_rank", 
                         "sgSCR_post_rank", 
                         "MBD2KO_pre_rank")] <- -log(ranked_qlf_output_hits$PValue,base =10) * 
  sign(ranked_qlf_output_hits[, c("logFC.samples.cell_typesgSCR_pre",
                                        "logFC.samples.cell_typesgSCR_post",
                                        "logFC.samples.cell_typeMBD2KO_pre")])


sgSCR_pre_qlf_output_hits <- ranked_qlf_output_hits[order(ranked_qlf_output_hits$sgSCR_pre_rank),]
sgSCR_post_qlf_output_hits <- ranked_qlf_output_hits[order(ranked_qlf_output_hits$sgSCR_post_rank),]
MBD2KO_pre_qlf_output_hits <- ranked_qlf_output_hits[order(ranked_qlf_output_hits$MBD2KO_pre_rank),]
```

Save sgSCR_pre upregulated genes and downregulated genes compared to MBD2KO_post cells.
```{r}
sgSCR_pre_upreg_genes <- rownames(sgSCR_pre_qlf_output_hits)[
  which(sgSCR_pre_qlf_output_hits$PValue < 0.05 
        & sgSCR_pre_qlf_output_hits$logFC.samples.cell_typesgSCR_pre > 0)]

sgSCR_pre_upreg<- sgSCR_pre_qlf_output_hits[sgSCR_pre_upreg_genes, 
                                            "logFC.samples.cell_typesgSCR_pre"]
names(sgSCR_pre_upreg) <- sgSCR_pre_upreg_genes

sgSCR_pre_downreg_genes <- rownames(sgSCR_pre_qlf_output_hits)[
  which(sgSCR_pre_qlf_output_hits$PValue < 0.05 
        & sgSCR_pre_qlf_output_hits$logFC.samples.cell_typesgSCR_pre < 0)]

sgSCR_pre_downreg<- sgSCR_pre_qlf_output_hits[sgSCR_pre_downreg_genes, 
                                            "logFC.samples.cell_typesgSCR_pre"]
names(sgSCR_pre_downreg) <- sgSCR_pre_downreg_genes
```

Save sgSCR_post upregulated and downregulated genes compared to the MBD2KO_post cells.
```{r}
sgSCR_post_upreg_genes <- rownames(sgSCR_post_qlf_output_hits)[
  which(sgSCR_post_qlf_output_hits$PValue < 0.05 
        & sgSCR_post_qlf_output_hits$logFC.samples.cell_typesgSCR_post > 0)]

sgSCR_post_upreg<- sgSCR_post_qlf_output_hits[sgSCR_post_upreg_genes, 
                                            "logFC.samples.cell_typesgSCR_post"]
names(sgSCR_post_upreg) <- sgSCR_post_upreg_genes

sgSCR_post_downreg_genes <- rownames(sgSCR_post_qlf_output_hits)[
  which(sgSCR_post_qlf_output_hits$PValue < 0.05 
        & sgSCR_post_qlf_output_hits$logFC.samples.cell_typesgSCR_post < 0)]

sgSCR_post_downreg<- sgSCR_post_qlf_output_hits[sgSCR_post_downreg_genes, 
                                            "logFC.samples.cell_typesgSCR_post"]
names(sgSCR_post_downreg) <- sgSCR_post_downreg_genes
```

Save MBD2KO_pre upregulated genes and downregulated genes compared to the MBC2KO_post cells.
```{r}
MBD2KO_pre_upreg_genes <- rownames(MBD2KO_pre_qlf_output_hits)[
  which(MBD2KO_pre_qlf_output_hits$PValue < 0.05 
        & MBD2KO_pre_qlf_output_hits$logFC.samples.cell_typeMBD2KO_pre > 0)]

MBD2KO_pre_upreg<- MBD2KO_pre_qlf_output_hits[MBD2KO_pre_upreg_genes, 
                                            "logFC.samples.cell_typeMBD2KO_pre"]
names(MBD2KO_pre_upreg) <- MBD2KO_pre_upreg_genes

MBD2KO_pre_downreg_genes <- rownames(MBD2KO_pre_qlf_output_hits)[
  which(MBD2KO_pre_qlf_output_hits$PValue < 0.05 
        & MBD2KO_pre_qlf_output_hits$logFC.samples.cell_typeMBD2KO_pre < 0)]

MBD2KO_pre_downreg<- MBD2KO_pre_qlf_output_hits[MBD2KO_pre_downreg_genes, 
                                            "logFC.samples.cell_typeMBD2KO_pre"]
names(MBD2KO_pre_downreg) <- MBD2KO_pre_downreg_genes
```

Now write the tables in the data folder for later use.
```{r}
write.table(sgSCR_pre_upreg,
            file=file.path("data","sgSCR_pre_upreg.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)
write.table(sgSCR_pre_downreg,
            file=file.path("data","sgSCR_pre_downreg.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)
write.table(sgSCR_post_upreg,
            file=file.path("data","sgSCR_post_upreg.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)
write.table(sgSCR_post_downreg,
            file=file.path("data","sgSCR_post_downreg.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)
write.table(MBD2KO_pre_upreg,
            file=file.path("data","MBD2KO_pre_upreg.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)
write.table(MBD2KO_pre_downreg,
            file=file.path("data","MBD2KO_pre_downreg.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)

```

### Enrichment Analysis

I chose the GO Biological Process annotation dataset, as I wanted to see how the differentially expressed gene sets contribute to erythroid cell differentiation. I am using the most recent aversion of the dataset available from enrichR, which is GO_Biological_Process_2018.
```{r}
library(enrichR)

sgSCR_pre_up_enrich <- enrichr(names(sgSCR_pre_upreg), "GO_Biological_Process_2018")
sgSCR_pre_down_enrich <- enrichr(names(sgSCR_pre_downreg), "GO_Biological_Process_2018")
sgSCR_post_up_enrich <- enrichr(names(sgSCR_post_upreg), "GO_Biological_Process_2018")
sgSCR_post_down_enrich <- enrichr(names(sgSCR_post_downreg), "GO_Biological_Process_2018")
MBD2KO_pre_up_enrich <- enrichr(names(MBD2KO_pre_upreg), "GO_Biological_Process_2018")
MBD2KO_pre_down_enrich <- enrichr(names(MBD2KO_pre_downreg), "GO_Biological_Process_2018")
```

Let's see the top 15 hits from each enrichment analysis.\
First we will look at the sgSCR_pre and MBD2KO_pre upregulated genes enrichment analysis side by side.
```{r}
sgSCR_pre_up_enrich_table <- sgSCR_pre_up_enrich$GO_Biological_Process_2018[1:15,
                                                                         c("Term", 
                                                                           "Overlap", 
                                                                           "Adjusted.P.value")]

MBD2KO_pre_up_enrich_table <- MBD2KO_pre_up_enrich$GO_Biological_Process_2018[1:15,
                                                                         c("Term", 
                                                                           "Overlap", 
                                                                           "Adjusted.P.value")]

sg <- knitr::kable(sgSCR_pre_up_enrich_table,
             "html", align = 'clc', caption = 'Enrichment Analysis of sgSCR_pre Upregulated Genes')
mbd <- knitr::kable(MBD2KO_pre_up_enrich_table,
             "html", align = 'clc', caption = 'Enrichment Analysis of MBD2KO_pre Upregulated Genes')

kableExtra::kable_styling(sg, full_width = FALSE, position = "float_left")
kableExtra::kable_styling(mbd, full_width = FALSE, position = "right")

```

10 out of the 15 biological processes are identical and most of the processes in both sgSCR_pre and MBD2KO_pre seem to have different kinds of RNA processing, and protein production processes enhanced compared to the MBD2KO_post cells.
```{r}
sgSCR_pre_down_enrich_table <- sgSCR_pre_down_enrich$GO_Biological_Process_2018[1:15,
                                                                         c("Term", 
                                                                           "Overlap", 
                                                                           "Adjusted.P.value")]

MBD2KO_pre_down_enrich_table <- MBD2KO_pre_down_enrich$GO_Biological_Process_2018[1:15,
                                                                         c("Term", 
                                                                           "Overlap", 
                                                                           "Adjusted.P.value")]


if (!requireNamespace("kableExtra")){
  install.packages("kableExtra")
}

sg <- knitr::kable(sgSCR_pre_down_enrich_table,
             "html", align = 'clc', caption = 'Enrichment Analysis of sgSCR_pre Downregulated Genes')
mbd <- knitr::kable(MBD2KO_pre_down_enrich_table,
             "html", align = 'clc', caption = 'Enrichment Analysis of MBD2KO_pre Downregulated Genes')

kableExtra::kable_styling(sg, full_width = FALSE, position = "float_left")
kableExtra::kable_styling(mbd, full_width = FALSE, position = "right")

```

8 out of the top 15 biological processes are overlapping. We can see that in both sgSCR_pre and MBD2KO_pre cell types, many biological processes pertaining to the regulation and mechanism of the mitotic cell cycle are downregulated. \

Now let's see the enrichment analyses result of the sgSCR_post cells.

```{r}
sgSCR_post_up_enrich_table <- sgSCR_post_up_enrich$GO_Biological_Process_2018[1:15,
                                                                         c("Term", 
                                                                           "Overlap", 
                                                                           "Adjusted.P.value")]

sgSCR_post_down_enrich_table <- sgSCR_post_down_enrich$GO_Biological_Process_2018[1:15,
                                                                         c("Term", 
                                                                           "Overlap", 
                                                                           "Adjusted.P.value")]

sg_up <- knitr::kable(sgSCR_post_up_enrich_table,
             "html", align = 'clc', caption = 'Enrichment Analysis of sgSCR_post Upregulated Genes')
sg_down <- knitr::kable(sgSCR_post_down_enrich_table,
             "html", align = 'clc', caption = 'Enrichment Analysis of sgSCR_post Downregulated Genes')

kableExtra::kable_styling(sg_up, full_width = FALSE, position = "float_left")
kableExtra::kable_styling(sg_down, full_width = FALSE, position = "right")

```
Above shows that there aren't much biological process related to cell cycle or differentiation up or down regulated in sgSCR_post cell type compared to the MBD2KO_post cell type.\
\
Overall the results of the enrichment analysis support the conclusions discussed in the original paper, as the control (sgSCR) and experimental (MBD2KO) cell types (pre and post) have minimal difference between each other. This supports their claim that MBD2KO has great potential to be a widely helpful in sickle cell amenia patients, as MBD2KO doesn't have adverse side effects. \
Unfortunately, because this study is fairly new (published in 2019), there hasn't been other published studies to support this view that MBD2KO elevates levels of HbF AND does not have adverse side effects in erythroid differentiation. 


## References
[1] Yu, X., Azzo, A., Bilinovich, S. M., Li, X., Dozmorov, M., Kurita, R., Nakamura, Y., Williams, D. C., Ginder, G. D. (2019) Disruption of the MBD2-NuRD Complex But Not MBD3-NuRD Induces High Level HbF Expression in Human Adult Erythroid Cells. Haematologica 104:2361-2371; doi:10.3324/haematol.2018.210963

[2] Davis, S., Meltzer, P. (2007) "GEOquery: a bridge between the Gene Expression Omnibus (GEO) and Bioconductor." Bioinformatics 14: 1846-1847

[3] Robinson MD, McCarthy DJ and Smyth GK (2010). edgeR: a Bioconductor package for differential expression analysis of digital gene expression data. Bioinformatics 26, 139-140

[4] McCarthy DJ, Chen Y and Smyth GK (2012). Differential expression analysis of multifactor RNA-Seq experiments with respect to biological variation. Nucleic Acids Research 40, 4288-4297

[5] Durinck, S, Spellman, P. T., Birney, E., Huber, w. (2009) Mapping identifiers for the integration of genomic datasets with the R/Bioconductor package biomaRt. Nature Protocols 4, 1184-1191

[6] Dunrinck, W., Moreau, Y., Kasprzyk, A., Davis, S., Moor, B. D., Brazma, A., Huber, W. (2005) BioMart and Bioconductor: a powerful link between biological databases and microarray data analysis. Bioinformatics 21, 3439-3440

[7]Gu Z, Eils R, Schlesner M (2016). "Complex heatmaps reveal patterns and correlations in multidimensional genomic data." Bioinformatics.

[8]Gu, Z. (2014) circlize implements and enhances circular visualization in R. Bioinformatics. DOI: 10.1093/bioinformatics/btu393

[9]Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, Smyth GK (2015). "limma powers differential expression analyses for RNA-sequencing and microarray studies." Nucleic Acids Research, 43(7), e47. doi: 10.1093/nar/gkv007.

[10]Kuleshov, M. V., Jones, M. R., Rouillard, A. D., Fernandez, N. F., Duan, Q., Wang, Z., Koplev, S., Jenkins, S. L., Jagodnik, K. M., Lachmann, A., McDermott, M. G., Monteiro, C. D., Gundersen, G. W., & Ma'ayan, A. (2016). Enrichr: a comprehensive gene set enrichment analysis web server 2016 update. Nucleic acids research, 44(W1), W90-W97. https://doi.org/10.1093/nar/gkw377
